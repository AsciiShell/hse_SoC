%!TEX TS-program = xelatex

% Шаблон документа LaTeX создан в 2018 году
% Алексеем Подчезерцевым
% В качестве исходных использованы шаблоны
% 	Данилом Фёдоровых (danil@fedorovykh.ru) 
%		https://www.writelatex.com/coursera/latex/5.2.2
%	LaTeX-шаблон для русской кандидатской диссертации и её автореферата.
%		https://github.com/AndreyAkinshin/Russian-Phd-LaTeX-Dissertation-Template

\documentclass[a4paper,14pt]{article}

\input{data/preambular.tex}
\begin{document} % конец преамбулы, начало документа
	\input{data/title.tex}
	\tableofcontents
	\pagebreak
	\section{Задание}
	
	\begin{enumerate}
		\item Увеличьте разрядность данных до 8, а количество ячеек до 2048. Представьте результаты
		моделирования и синтеза в RTL и объясните их. Загрузите результаты в Technology Мар
		Viewer и дайте описание того, что получится.
		
		\item Самостоятельно изучите решение описанной выше проблемы (например, в обсуждении на
		форуме Electronix). Реализовать ПЗУ на встроенной памяти.
		
		\item Измените целевую микросхему на любой чип из семейства Cyclone V. Представьте
		результаты компиляции и синтеза в RTL и объясните их. Загрузите результаты в Technology
		Мар Viewer и опишите полученные результаты.
		
		\item Проверьте , как изменится размер двухпортовой памяти при увеличении разрядности шины
		адреса до 8, 10, 12, 16 бит. Представьте результаты компиляции и синтеза в RTL, опишите и
		объясните полученные результаты.
		
		\item Проанализируйте, как изменится размер стека при увеличении глубины стека до 32, 64, 128,
		256 элементов. Представьте результаты компиляции и синтеза в RTL Viewer и объясните их.
		Загрузите результаты в Technology Мар Viewer, опишите и объясните полученные
		результаты.
		
		\item Реализуйте два варианта очереди как в случае со стеком в Разделе 7.9 с глубиной до 32, 64,
		128, 256 элементов. Представьте результаты компиляции и синтеза в RTL Viewer и объясните
		их. Загрузите результаты в Technology Мар Viewer, опишите и объясните полученные
		результаты.
		
		\item Модифицируйте пример и з Листинга 7.16 так, чтобы данный модуль был
		параметризируемый, и можно было задать память любого размера кратного 16 словам по 6
		бит. Опишите полученный модуль и его работу.
	\end{enumerate}
	
	\section{Дополнительные задания}
	
	\subsection{Задание 1}
	
	На RTL представлении можно видеть 2 блока: первый это синхронный D-триггер в который записывается текущий адрес, второй блок представлен блоком RAM. На TMV можно видеть 8 синхронный однобитных D-триггеров, в которых хранится текущий адрес. Информация хранится в 8 блоках RAM по 256 бит каждый.
	
	RLT диаграмма на рис. \ref{fig:z1_rtl}. Technology Мар Viewer на рис. \ref{fig:z1_tmv}.
	 
	\begin{figure}[H]
		\centering
		\includegraphics[width=\linewidth]{images/z1_rtl}
		\caption{RTL-схема}
		\label{fig:z1_rtl}
	\end{figure}

	\begin{figure}[H]
		\centering
		\includegraphics[width=0.65\linewidth]{images/z1_tmv}
		\caption{Technology Мар Viewer}
		\label{fig:z1_tmv}
	\end{figure}

	\VerbatimInput{../z1/lab7_3.v}
	
	\subsection{Задание 2}
	
	Результат компиляции на рис. \ref{fig:z2_report}. Результат симуляции на рис. \ref{fig:z2_sim}.
	
	\VerbatimInput{../z2/lab7_rom.v}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\linewidth]{images/z2_report}
		\caption{Отчет о компиляции}
		\label{fig:z2_report}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=\linewidth]{images/z2_sim}
		\caption{Результат симуляции}
		\label{fig:z2_sim}
	\end{figure}

	\subsection{Задание 3}
	
	RTL диаграмма на рис. \ref{fig:z3_rtl}. Technology Мар Viewer на рис. \ref{fig:z3_tmv}.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\linewidth]{images/z3_rtl}
		\caption{RTL-схема}
		\label{fig:z3_rtl}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=\linewidth]{images/z3_tmv}
		\caption{Technology Мар Viewer}
		\label{fig:z3_tmv}
	\end{figure}
	
	\subsection{Задание 4}
	
	RTL диаграмма на рис. \ref{fig:z4_rtl_16bit}. Результаты компиляции для 8 и 16 разрядов соответственно на рис. \ref{fig:z4_res_8bit} и рис. \ref{fig:z4_res_16bit}.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\linewidth]{images/z4_rtl_16bit}
		\caption{RTL-схема для 16 разрядов}
		\label{fig:z4_rtl_16bit}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{images/z4_res_8bit}
		\caption{Результаты компиляции для 8 разрядов}
		\label{fig:z4_res_8bit}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{images/z4_res_16bit}
		\caption{Результаты компиляции для 16 разрядов}
		\label{fig:z4_res_16bit}
	\end{figure}
	
	\subsection{Задание 5}
	
	Результаты компиляции для глубины стека 32 и 256 соответственно на рис. \ref{fig:z5_res_32} и рис. \ref{fig:z5_res_256}.
		
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{images/z5_res_32}
		\caption{Результаты компиляции для 8 разрядов}
		\label{fig:z5_res_32}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{images/z5_res_256}
		\caption{Результаты компиляции для 16 разрядов}
		\label{fig:z5_res_256}
	\end{figure}
	
	\subsection{Задание 6}
	
	Текст кода первой реализации очереди:
	
	\VerbatimInput{../z1/lab7_6_q.v}
	
	RTL представление и TMV для глубины в 256 для первой реализации очереди представлено на рис.  \ref{fig:z6_rtl_256_v1} и  \ref{fig:z6_tmv_256_v1} соответственно:
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\linewidth]{images/z6_rtl_256_v1}
		\caption{RTL-схема для глубины 256}
		\label{fig:z6_rtl_256_v1}
	\end{figure}

	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\linewidth]{images/z6_tmv_256_v1}
		\caption{TMV представление для глубины 256}
		\label{fig:z6_tmv_256_v1}
	\end{figure}
	
	Текст кода второй реализации очереди:
	
	\VerbatimInput{../z1/lab7_7_q.v}
	
	RTL представление и TMV для глубины в 256 для второй реализации очереди представлено на рис.  \ref{fig:z6_rtl_256_v2} и  \ref{fig:z6_tmv_256_v2} соответственно:
	
		\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\linewidth]{images/z6_rtl_256_v2}
		\caption{RTL-схема для глубины 256}
		\label{fig:z6_rtl_256_v2}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\linewidth]{images/z6_tmv_256_v2}
		\caption{TMV представление для глубины 256}
		\label{fig:z6_tmv_256_v2}
	\end{figure}
	
	\subsection{Задание 7}
	
	Текст кода:
	
	\VerbatimInput{../z1/SRAM_BANK_xN.v}
	
		
	\section{Задания для самостоятельной работы}
	
	Разработайте схему простой двухпортовой памяти, которая будет хранить данные о
	цветном изображении с глубиной цвета 8 бит и разрешением 212х104.
	
	Текст кода:
	
	\VerbatimInput{../z1/images.v}
			
	\section{Контрольные вопросы}
	
	\begin{enumerate}
		\item Опишите, как строятся регистры на основе D-триггеров.
		
		Регистры строятся путем комбинации нескольких D-триггеров и выбором нужного значения с помощью мультиплексора.
		
		\item Как организованы массивы ячеек памяти?
		
		При подаче сигнала на выход подается сигнал с определенной строки матрицы.
		
		\item Приведите примеры типов входов и выходов памяти. Опишите их назначение.
		
		Адрес -- определяет откуда будет производиться чтение или запись.
		
		Входные-выходные данные.
		
		Сигнал разрешения записи.
		
		\item Какими бывают режимы работы памяти? Опишите их.
		
		Режим чтения, режим записи, режим хранения, режим регенерации.
		
		\item Какими бывают виды двухпортовой памяти? Опишите режимы ее работы.
		
		Простая -- один порт для записи, другой для чтения.
		
		Полная -- два полноценных порта с возможностью чтения и записи.
		
		\item Что такое «информационная емкость»? Как ее рассчитать?
		
		$ data\_width * 2 ^ {address\_width} $
		
		Суммарный возможный объем памяти для данных параметров ширины шины адреса и данных.
		
		\item Какими бывают типы запоминающих устройств?
		
		SRAM, DRAM, ROM, PROM, EPROM, EEPROM.
		
		\item Как можно классифицировать память по функциям, которые она выполняет?
		
		Зависимость от питания, перепрограммируемость, время доступа, задержки.
		
		\item Как устроен логический элемент микросхемы Intel FPGA MAX10?
		
		\item Опишите варианты конфигурации блока памяти М9К в микросхеме MAX10.
		
		ОЗУ, ПЗУ, одно- или двухпортовую память, регистр сдвига, FIFO.
		
		\item Как реализовать ПЗУ с помощью таблицы перекодировки? Приведите пример на Verilog.
		
		При подаче определенного сигнала на выход выдается определенная константа.
		Реализуется с помощью оператора case.
		
		\item Для чего используется память вида «стек»? Опишите работу стека.
		
		Стек -- одна из основных структур данных, позволяет либо добавить один элемент в коллекцию, или забрать один, при чем будет вернут самый последний положенный элемент из всех в коллекции.
		Широко используется, например для хранения состояния программы.
		
		\item Как реализовать стек с помощью сдвигового регистра? Приведите пример на Verilog.
		
		\item Как реализовать стек с помощью сдвига указателя? Приведите пример на Verilog.
		
		\item Как реализовать FIFO? Приведите пример на Verilog.
		
		\item Как устроена встроенная память микросхем ASIC?
		
		На основе пустых кристаллов и библиотечных функций фабрики-производителя создается оптимизированная и компактная схема с требуемыми параметрами.
		
	\end{enumerate}
	
	\section{Выводы по работе}
	
	В ходе работы получен опыт проектирования схем в программе Quartus с помощью языка Verilog.
	Полученное устройство было протестировано с помощью бенчтестов в программе Quartus Simulation Waveform editor и ModelSim.
	В процессе работы были смоделированы запоминающие устройства, очередь, стек.
	%В процессе работы были смоделированы различные шифраторы и дешифраторы, протестированы способы оптимизации схемы, а так же рассчитаны временные параметры схемы с различными способами оптимизации.
	В процессе был получен опыт работы с платой DE10-Lite, на которой проверялась работоспособность полученного устройства.
	
	\newpage 
	\renewcommand{\refname}{{\normalsize Список использованных источников}} 
	\centering 
	\begin{thebibliography}{9} 
		\addcontentsline{toc}{section}{\refname} 
		\bibitem{Verilog} Thomas D., Moorby P. The Verilog Hardware Description Language. – Springer Science \& Business Media, 2008.
		\bibitem{citekey} Khor W. Y. et al. Evaluation of FPGA Based QSPI Flash Access Using Partial Reconfiguration //2019 7th International Conference on Smart Computing \& Communications (ICSCC). – IEEE, 2019. – С. 1-5
	\end{thebibliography}
	
\end{document} % конец документа
